## containerization_orchestration

### Project Overview

This repository contains laboratory works related to containerization and orchestration, each in a separate branch.

### Branches:

- **Lab 1**: `lab1` [branch lab1 ](https://github.com/alexiv-tn65/containerization_orchestration/tree/lab1)
- **Lab 2**: `lab2` [branch lab2 ](https://github.com/alexiv-tn65/containerization_orchestration/tree/lab2)
- **Lab 3**: `lab3` [branch lab3 ](https://github.com/alexiv-tn65/containerization_orchestration/tree/lab3)
- **Lab 4**: `lab4` [branch lab4 ](https://github.com/alexiv-tn65/containerization_orchestration/tree/lab4)



## Плохие практики в коде Dockerfile

#### 1. Отсутствие очистки кэша после установки пакетов
В плохом Dockerfile не производится очистка кэша после установки пакетов, что приводит к увеличению размера образа. В хорошем Dockerfile используется команда `rm -rf /var/lib/apt/lists/*`, чтобы удалить ненужные файлы после установки.

#### 2. Запуск приложения без параметров
В плохом Dockerfile `ENTRYPOINT` запускает `jupyter` без всех необходимых параметров, что может привести к недостаточной информации о работе приложения. В хорошем Dockerfile добавлен параметр `--log-level=DEBUG`, что позволяет лучше отслеживать выполнение приложения.

#### 3. Создание volume без указания точки монтирования. 
В плохом Dockerfile используется инструкция VOLUME без явного указания, как и где будет использоваться этот том. В хорошем Dockerfile создается volume с указанием точки монтирования, что делает его использование более понятным.

#### 4. Плохой Dockerfile устанавливает необходимые пакеты в разных командах, что создает дополнительные слои и увеличивает размер образа. 
В хорошем Dockerfile все необходимые пакеты устанавливаются в одной команде с использованием `&&`, что оптимизирует процесс сборки. Каждый слой содержит изменения файловой системы, и чем больше слоев, тем больше размер итогового образа. Ускорение процесса сборки с использованием `&&`: Сборка происходит быстрее, так как Docker должен обрабатывать меньше слоев.

#### 5. Использование флага --no-install-recommends позволяет избежать установки рекомендованных пакетов, что значительно уменьшает размер образа и ускоряет процесс сборки. 
Это помогает установить только необходимые зависимости, экономя место и время.Рекомендованные пакеты часто включают дополнительные библиотеки и инструменты, которые могут не понадобиться для работы вашего приложения. 

#### 6. Использование тега latest в Dockerfile. 
Например, FROM python:latest, делает образ нестабильным, так как он всегда ссылается на последнюю доступную версию. Это может привести к непредсказуемому поведению приложения из-за изменений в обновлениях, затрудняет управление версиями и может вызвать проблемы с безопасностью. Рекомендуется использовать фиксированные версии образов, такие как FROM python:3.11-slim, чтобы обеспечить стабильность и предсказуемость окружения. 
И выбрать именно ту версию образа, которая требуется.


### Плохие практики по использованию контейнеров

#### 1. Неиспользование volume для хранения данных
Если данные хранятся внутри контейнера, они будут потеряны при его удалении. Использование volume позволяет сохранять данные вне контейнера и обеспечивает их доступность даже после перезапуска или удаления контейнера.

#### 2. Запуск нескольких процессов в одном контейнере
Запуск нескольких процессов в одном контейнере затрудняет управление и мониторинг. Рекомендуется придерживаться принципа "один процесс — один контейнер". Это обеспечивает лучшую изоляцию и управление каждым процессом отдельно. Когда в одном контейнере работают несколько процессов, становится сложнее управлять их состоянием. Например, если один из процессов завершает свою работу с ошибкой, это может повлиять на другие процессы внутри того же контейнера. В результате может возникнуть ситуация, когда контейнер продолжает работать, хотя одно из его приложений уже не функционирует.

#### 3. Создание различных образов для каждой среды (dev, stage, prod):
Это может привести к дублированию кода и усложнению управления версиями. Лучше использовать один образ с конфигурацией, адаптированной для разных сред.
(Зависит от конкретной ситуации.)



### Случаи, когда не стоит использовать контейнеры:

#### 1. Приложения с высокими требованиями к производительности
Для приложений, требующих низкой задержки (например системы реального времени: cистемы управления полетом, медицинские устройства) и высокой производительности, накладные расходы на виртуализацию контейнеров могут стать проблемой, и лучше использовать нативные решения.

#### 2. Легаси-приложения:
Существующие приложения, которые уже работают на сервере и не требуют изменений, могут быть сложными для контейнеризации. Перенос таких приложений в контейнеры может потребовать значительных усилий и времени.

#### 3. Небольшие одноразовые скрипты
Если задача заключается в выполнении простого одноразового скрипта, использование контейнеров может добавить ненужную сложность.

#### 4. Приложения с большими зависимостями
Если приложение требует установки большого количества библиотек и зависимостей, это может сделать образ слишком тяжелым и сложным в управлении.


### Сборка и запуск контейнера `my-jupyter-notebook`

#### Сборка образа

```bash
docker build -t my-jupyter-notebook -f Dockerfile .
```

#### Запуск контейнера

```bash
docker run -d -p 8888:8888 my-jupyter-notebook
```
или
```bash
docker run -d -p 8888:8888 --name my-jupyter-notebook my-jupyter-notebook
```


#### Проверка работы приложения

```bash
http://localhost:8888/
```

#### Получение доступа к терминалу контейнера

```bash
docker exec -it my-jupyter-notebook /bin/bash
```
