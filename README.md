## containerization_orchestration

### Project Overview

This repository contains four laboratory works related to containerization and orchestration, each in a separate branch.

### Branches:

- **Lab 1**: `lab1`
- **Lab 2**: `lab2`
- **Lab 3**: `lab3`
- **Lab 4**: `lab4`


/project-directory
│
├── Dockerfile.bad
├── Dockerfile.good
└── README.md


# Плохие практики в коде Dockerfile

## 1. Отсутствие очистки кэша после установки пакетов
В плохом Dockerfile не производится очистка кэша после установки пакетов, что приводит к увеличению размера образа. В хорошем Dockerfile используется команда `rm -rf /var/lib/apt/lists/*`, чтобы удалить ненужные файлы после установки.

## 2. Запуск приложения без параметров
В плохом Dockerfile `ENTRYPOINT` запускает `jupyterhub` без параметров, что может привести к недостаточной информации о работе приложения. В хорошем Dockerfile добавлен параметр `--log-level=DEBUG`, что позволяет лучше отслеживать выполнение приложения.

## 3. Избыточная установка пакетов
Плохой Dockerfile устанавливает необходимые пакеты в разных командах, что создает дополнительные слои и увеличивает размер образа. В хорошем Dockerfile все необходимые пакеты устанавливаются в одной команде с использованием `&&`, что оптимизирует процесс сборки.

# Плохие практики по использованию контейнеров

## 1. Неиспользование volume для хранения данных
Если данные хранятся внутри контейнера, они будут потеряны при его удалении. Использование volume позволяет сохранять данные вне контейнера и обеспечивает их доступность даже после перезапуска или удаления контейнера.

## 2. Запуск нескольких процессов в одном контейнере
Запуск нескольких процессов в одном контейнере затрудняет управление и мониторинг, так как каждый процесс должен иметь собственный контейнер для лучшей изоляции и управления.

# Случаи, когда не стоит использовать контейнеры

## 1. Небольшие одноразовые скрипты
Если задача заключается в выполнении простого одноразового скрипта, использование контейнеров может добавить ненужную сложность.

## 2. Приложения с высокими требованиями к производительности
Для приложений, требующих низкой задержки и высокой производительности, накладные расходы на виртуализацию контейнеров могут стать проблемой, и лучше использовать нативные решения.
